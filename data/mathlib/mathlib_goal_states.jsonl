{"statement_idx": 0, "goal_state": "R : Type u_1\ninst✝ : Semiring R\n⊢ Function.Injective ⇑(C R)"}
{"statement_idx": 1, "goal_state": "R : Type u_1\ninst✝ : Semiring R\n⊢ Subsingleton R⟦X⟧ ↔ Subsingleton R"}
{"statement_idx": 2, "goal_state": "R : Type u_1\ninst✝ : Semiring R\n⊢ Function.Surjective ⇑(constantCoeff R)"}
{"statement_idx": 3, "goal_state": "R : Type u_1\nA : Type u_2\ninst✝ : CommRing A\n⊢ ¬IsField A⟦X⟧"}
{"statement_idx": 4, "goal_state": "R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ Irreducible X"}
{"statement_idx": 5, "goal_state": "R : Type u_1\ninst✝ : Semiring R\nφ f : R⟦X⟧\nhf : f ≠ 0\n⊢ X ^ (order f).get ⋯ * divided_by_X_pow_order hf = f"}
{"statement_idx": 6, "goal_state": "R : Type u_1\ninst✝¹ : Semiring R\ninst✝ : Nontrivial R\nf : R⟦X⟧\n⊢ IsUnit f → order f = 0"}
{"statement_idx": 7, "goal_state": "R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ divided_by_X_pow_order ⋯ = 1"}
{"statement_idx": 8, "goal_state": "R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nf g : R⟦X⟧\nhf : f ≠ 0\nhg : g ≠ 0\n⊢ divided_by_X_pow_order hf * divided_by_X_pow_order hg = divided_by_X_pow_order ⋯"}
{"statement_idx": 9, "goal_state": "V : Type u\nV' : Type v\nV'' : Type w\nG : SimpleGraph V\nG' : SimpleGraph V'\nG'' : SimpleGraph V''\ninst✝ : DecidableEq V\nu v : V\np : Walk G u v\nh : length p ≤ length (bypass p)\n⊢ bypass p = p"}
{"statement_idx": 10, "goal_state": "V : Type u_1\nG : SimpleGraph V\nu v : V\np : Walk G u v\nhp : length p = dist G u v\n⊢ IsPath p"}
{"statement_idx": 11, "goal_state": "V : Type u_1\nG : SimpleGraph V\nu v : V\nhr : Reachable G u v\n⊢ ∃ p, Walk.IsPath p ∧ Walk.length p = dist G u v"}
{"statement_idx": 12, "goal_state": "V : Type u_1\nG : SimpleGraph V\nhconn : Connected G\nu v : V\n⊢ ∃ p, Walk.IsPath p ∧ Walk.length p = dist G u v"}
{"statement_idx": 13, "goal_state": "ι : Type u_1\n𝕜 : Type u_2\nE✝ : Type u_3\nE : Type u_4\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module ℝ E\ninst✝² : TopologicalSpace E\ninst✝¹ : TopologicalAddGroup E\ninst✝ : ContinuousSMul ℝ E\np q : Submodule ℝ E\nhpq : IsCompl p q\nhpc : IsPathConnected {0}ᶜ\n⊢ IsPathConnected (↑q)ᶜ"}
{"statement_idx": 14, "goal_state": "F : Type u_1\ninst✝⁴ : AddCommGroup F\ninst✝³ : Module ℝ F\ninst✝² : TopologicalSpace F\ninst✝¹ : TopologicalAddGroup F\ninst✝ : ContinuousSMul ℝ F\nE : Submodule ℝ F\nhcodim : 1 < Module.rank ℝ (F ⧸ E)\n⊢ IsPathConnected (↑E)ᶜ"}
{"statement_idx": 15, "goal_state": "F : Type u_1\ninst✝⁴ : AddCommGroup F\ninst✝³ : Module ℝ F\ninst✝² : TopologicalSpace F\ninst✝¹ : TopologicalAddGroup F\ninst✝ : ContinuousSMul ℝ F\nE : Submodule ℝ F\nhcodim : 1 < Module.rank ℝ (F ⧸ E)\n⊢ IsConnected (↑E)ᶜ"}
{"statement_idx": 16, "goal_state": "F : Type u_1\ninst✝⁴ : AddCommGroup F\ninst✝³ : Module ℝ F\ninst✝² : TopologicalSpace F\ninst✝¹ : TopologicalAddGroup F\ninst✝ : ContinuousSMul ℝ F\nE : Submodule ℝ F\nhcodim : 1 < Module.rank ℝ (F ⧸ E)\nx : F\nhx : x ∉ E\n⊢ connectedComponentIn (↑E)ᶜ x = (↑E)ᶜ"}
{"statement_idx": 17, "goal_state": "α : Type u_1\nβ : Type u_2\nγ : Type u_3\nγ₂ : Type u_4\nδ : Type u_5\nι : Sort y\ns t u : Set α\ninst✝¹³ : TopologicalSpace α\ninst✝¹² : MeasurableSpace α\ninst✝¹¹ : OpensMeasurableSpace α\ninst✝¹⁰ : TopologicalSpace β\ninst✝⁹ : MeasurableSpace β\ninst✝⁸ : OpensMeasurableSpace β\ninst✝⁷ : TopologicalSpace γ\ninst✝⁶ : MeasurableSpace γ\ninst✝⁵ : BorelSpace γ\ninst✝⁴ : TopologicalSpace γ₂\ninst✝³ : MeasurableSpace γ₂\ninst✝² : BorelSpace γ₂\ninst✝¹ : MeasurableSpace δ\ninst✝ : T0Space α\n⊢ MeasurableSpace.SeparatesPoints α"}
{"statement_idx": 18, "goal_state": null}
{"statement_idx": 19, "goal_state": "α✝ : Type u_1\nβ : Type u_2\nγ : Type u_3\nγ₂ : Type u_4\nδ : Type u_5\nι : Sort y\ns t u : Set α✝\nα : Type u_6\nm : MeasurableSpace α\ninst✝ : HasCountableSeparatingOn α MeasurableSet univ\n⊢ ∃ τ, SecondCountableTopology α ∧ T4Space α ∧ OpensMeasurableSpace α"}
{"statement_idx": 20, "goal_state": "m n✝ n : ℕ\nι : Type u_1\ne : Fin (n + 1) ↪ ι\n⊢ ⇑((embeddingFinSucc n ι) e).fst = ⇑e ∘ Fin.succ"}
{"statement_idx": 21, "goal_state": "m n✝ n : ℕ\nι : Type u_1\ne : Fin (n + 1) ↪ ι\n⊢ ↑((embeddingFinSucc n ι) e).snd = e 0"}
{"statement_idx": 22, "goal_state": "m n✝ n : ℕ\nι : Type u_1\nf : (e : Fin n ↪ ι) × { i // i ∉ Set.range ⇑e }\n⊢ ⇑((embeddingFinSucc n ι).symm f) = Fin.cons ↑f.snd ⇑f.fst"}
{"statement_idx": 23, "goal_state": "α : Type u_1\nβ : Type u_2\nA : Type u_3\nB : Type u_4\nM : Type u_5\nN : Type u_6\nP : Type u_7\nR : Type u_8\nS : Type u_9\nG : Type u_10\nM₀ : Type u_11\nG₀ : Type u_12\nι : Sort u_13\ninst✝² : One M\ninst✝¹ : One N\ninst✝ : One P\nf g : α → M\n⊢ f = g ↔ mulSupport f = mulSupport g ∧ ∀ x ∈ mulSupport f, f x = g x"}
{"statement_idx": 24, "goal_state": "α : Type u_1\nβ : Type u_2\nA : Type u_3\nB : Type u_4\nM : Type u_5\nN : Type u_6\nP : Type u_7\nR : Type u_8\nS : Type u_9\nG : Type u_10\nM₀ : Type u_11\nG₀ : Type u_12\nι : Sort u_13\ninst✝³ : One M\ninst✝² : One N\ninst✝¹ : One P\ninst✝ : DecidableEq α\nf : α → M\nx : α\ny : M\nhy : y ≠ 1\n⊢ mulSupport (update f x y) = insert x (mulSupport f)"}
{"statement_idx": 25, "goal_state": "α : Type u_1\nβ : Type u_2\nA : Type u_3\nB : Type u_4\nM : Type u_5\nN : Type u_6\nP : Type u_7\nR : Type u_8\nS : Type u_9\nG : Type u_10\nM₀ : Type u_11\nG₀ : Type u_12\nι : Sort u_13\ninst✝³ : One M\ninst✝² : One N\ninst✝¹ : One P\ninst✝ : DecidableEq α\nf : α → M\nx : α\n⊢ mulSupport (update f x 1) = mulSupport f \\ {x}"}
{"statement_idx": 26, "goal_state": "α : Type u_1\nβ : Type u_2\nA : Type u_3\nB : Type u_4\nM : Type u_5\nN : Type u_6\nP : Type u_7\nR : Type u_8\nS : Type u_9\nG : Type u_10\nM₀ : Type u_11\nG₀ : Type u_12\nι : Sort u_13\ninst✝⁴ : One M\ninst✝³ : One N\ninst✝² : One P\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq M\nf : α → M\nx : α\ny : M\n⊢ mulSupport (update f x y) = if y = 1 then mulSupport f \\ {x} else insert x (mulSupport f)"}
{"statement_idx": 27, "goal_state": "R : Type u\ninst✝⁵ : CommRing R\nA B : Type u\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\ninst✝² : CommRing B\ninst✝¹ : Algebra R B\ninst✝ : Etale R A\ne : A ≃ₐ[R] B\n⊢ Etale R B"}
{"statement_idx": 28, "goal_state": "R : Type u\ninst✝⁸ : CommRing R\nA B : Type u\ninst✝⁷ : CommRing A\ninst✝⁶ : Algebra R A\ninst✝⁵ : CommRing B\ninst✝⁴ : Algebra R B\ninst✝³ : Algebra A B\ninst✝² : IsScalarTower R A B\ninst✝¹ : Etale R A\ninst✝ : Etale A B\n⊢ Etale R B"}
{"statement_idx": 29, "goal_state": "R : Type u\ninst✝⁵ : CommRing R\nA B : Type u\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\ninst✝² : CommRing B\ninst✝¹ : Algebra R B\nr : R\ninst✝ : IsLocalization.Away r A\n⊢ Etale R A"}
{"statement_idx": 30, "goal_state": "R : Type u\ninst✝⁵ : CommRing R\nA B : Type u\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\ninst✝² : CommRing B\ninst✝¹ : Algebra R B\ninst✝ : Unramified R A\ne : A ≃ₐ[R] B\n⊢ Unramified R B"}
{"statement_idx": 31, "goal_state": "R : Type u\ninst✝⁵ : CommRing R\nA B : Type u\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\ninst✝² : CommRing B\ninst✝¹ : Algebra R B\nr : R\ninst✝ : IsLocalization.Away r A\n⊢ Unramified R A"}
{"statement_idx": 32, "goal_state": "R : Type u\ninst✝⁸ : CommRing R\nA B : Type u\ninst✝⁷ : CommRing A\ninst✝⁶ : Algebra R A\ninst✝⁵ : CommRing B\ninst✝⁴ : Algebra R B\ninst✝³ : Algebra A B\ninst✝² : IsScalarTower R A B\ninst✝¹ : Unramified R A\ninst✝ : Unramified A B\n⊢ Unramified R B"}
{"statement_idx": 33, "goal_state": "C : Type u₁\ninst✝² : Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : Category.{v₂, u₂} J\nX : Type v₂\nα : Type u_1\nZ : α → C\ninst✝ : HasCoproduct Z\nc c' : Cofan Z\nf : Fan fun x => op (Z x)\nhc : IsColimit c\nhc' : IsColimit c'\nhf : IsLimit f\n⊢ (opCoproductIsoProduct' hc hf).hom ≫ (opCoproductIsoProduct' hc' hf).inv =\n    (Iso.op (IsColimit.coconePointUniqueUpToIso hc hc')).inv"}
{"statement_idx": 34, "goal_state": "C : Type u₁\ninst✝² : Category.{v₁, u₁} C\nJ : Type u₂\ninst✝¹ : Category.{v₂, u₂} J\nX : Type v₂\nα : Type u_1\nZ : α → C\ninst✝ : HasProduct Z\nf f' : Fan Z\nc : Cofan fun x => op (Z x)\nhf : IsLimit f\nhf' : IsLimit f'\nhc : IsColimit c\n⊢ (opProductIsoCoproduct' hf hc).hom ≫ (opProductIsoCoproduct' hf' hc).inv =\n    (Iso.op (IsLimit.conePointUniqueUpToIso hf hf')).inv"}
{"statement_idx": 35, "goal_state": "K : Type u_1\ninst✝¹⁵ : NormedLinearOrderedField K\ninst✝¹⁴ : HasSolidNorm K\ninst✝¹³ : FloorRing K\nE✝ : Type u_2\ninst✝¹² : NormedAddCommGroup E✝\ninst✝¹¹ : NormedSpace K E✝\ninst✝¹⁰ : FiniteDimensional K E✝\ninst✝⁹ : ProperSpace E✝\nL✝ : AddSubgroup E✝\ninst✝⁸ : DiscreteTopology ↥L✝\nι : Type u_3\nhs : IsZlattice K L✝\nb✝ : Basis ι ℤ ↥L✝\nE : Type u_4\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace ℝ E\ninst✝⁵ : FiniteDimensional ℝ E\nL : AddSubgroup E\ninst✝⁴ : DiscreteTopology ↥L\ninst✝³ : IsZlattice ℝ L\ninst✝² : _root_.Finite ι\nb : Basis ι ℤ ↥L\ninst✝¹ : MeasurableSpace E\ninst✝ : OpensMeasurableSpace E\nμ : MeasureTheory.Measure E\n⊢ MeasureTheory.IsAddFundamentalDomain (↥L) (Zspan.fundamentalDomain (Basis.ofZlatticeBasis ℝ L b)) μ"}
{"statement_idx": 36, "goal_state": "K : Type u_1\ninst✝¹² : NormedLinearOrderedField K\ninst✝¹¹ : HasSolidNorm K\ninst✝¹⁰ : FloorRing K\nE✝ : Type u_2\ninst✝⁹ : NormedAddCommGroup E✝\ninst✝⁸ : NormedSpace K E✝\ninst✝⁷ : FiniteDimensional K E✝\ninst✝⁶ : ProperSpace E✝\nL✝ : AddSubgroup E✝\ninst✝⁵ : DiscreteTopology ↥L✝\nι : Type u_3\nhs : IsZlattice K L✝\nb : Basis ι ℤ ↥L✝\nE : Type u_4\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace ℝ E\ninst✝² : FiniteDimensional ℝ E\nL : AddSubgroup E\ninst✝¹ : DiscreteTopology ↥L\ninst✝ : IsZlattice ℝ L\n⊢ Countable ↥L"}
{"statement_idx": 37, "goal_state": "E : Type u_1\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace ℝ E\ninst✝⁵ : FiniteDimensional ℝ E\ninst✝⁴ : MeasurableSpace E\ninst✝³ : BorelSpace E\nL : AddSubgroup E\ninst✝² : DiscreteTopology ↥L\ninst✝¹ : IsZlattice ℝ L\nμ : autoParam (Measure E) _auto✝\ninst✝ : Measure.IsAddHaarMeasure μ\nF : Set E\nh : IsAddFundamentalDomain (↥L) F μ\n⊢ covolume L μ = (↑↑μ F).toReal"}
{"statement_idx": 38, "goal_state": "E : Type u_1\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace ℝ E\ninst✝⁵ : FiniteDimensional ℝ E\ninst✝⁴ : MeasurableSpace E\ninst✝³ : BorelSpace E\nL : AddSubgroup E\ninst✝² : DiscreteTopology ↥L\ninst✝¹ : IsZlattice ℝ L\nμ : autoParam (Measure E) _auto✝\ninst✝ : Measure.IsAddHaarMeasure μ\n⊢ covolume L μ ≠ 0"}
{"statement_idx": 39, "goal_state": "E : Type u_1\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace ℝ E\ninst✝⁵ : FiniteDimensional ℝ E\ninst✝⁴ : MeasurableSpace E\ninst✝³ : BorelSpace E\nL : AddSubgroup E\ninst✝² : DiscreteTopology ↥L\ninst✝¹ : IsZlattice ℝ L\nμ : autoParam (Measure E) _auto✝\ninst✝ : Measure.IsAddHaarMeasure μ\n⊢ 0 < covolume L μ"}
{"statement_idx": 40, "goal_state": "E : Type u_1\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace ℝ E\ninst✝⁷ : FiniteDimensional ℝ E\ninst✝⁶ : MeasurableSpace E\ninst✝⁵ : BorelSpace E\nL : AddSubgroup E\ninst✝⁴ : DiscreteTopology ↥L\ninst✝³ : IsZlattice ℝ L\nμ : autoParam (Measure E) _auto✝\ninst✝² : Measure.IsAddHaarMeasure μ\nι : Type u_2\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nb : Basis ι ℤ ↥L\nb₀ : Basis ι ℝ E\n⊢ covolume L μ = |(Basis.det b₀) (Subtype.val ∘ ⇑b)| * (↑↑μ (Zspan.fundamentalDomain b₀)).toReal"}
{"statement_idx": 41, "goal_state": "E : Type u_1\ninst✝¹¹ : NormedAddCommGroup E\ninst✝¹⁰ : NormedSpace ℝ E\ninst✝⁹ : FiniteDimensional ℝ E\ninst✝⁸ : MeasurableSpace E\ninst✝⁷ : BorelSpace E\nL✝ : AddSubgroup E\ninst✝⁶ : DiscreteTopology ↥L✝\ninst✝⁵ : IsZlattice ℝ L✝\nμ : autoParam (Measure E) _auto✝\ninst✝⁴ : Measure.IsAddHaarMeasure μ\nι : Type u_2\ninst✝³ : Fintype ι\ninst✝² : DecidableEq ι\nL : AddSubgroup (ι → ℝ)\ninst✝¹ : DiscreteTopology ↥L\ninst✝ : IsZlattice ℝ L\nb : Basis ι ℤ ↥L\n⊢ covolume L volume = |Matrix.det (Matrix.of (Subtype.val ∘ ⇑b))|"}
{"statement_idx": 42, "goal_state": "C : Type u_1\nD : Type u_2\ninst✝² : Category.{u_3, u_1} C\ninst✝¹ : Category.{?u.7572, u_2} D\nL : C ⥤ D\nW : MorphismProperty C\ninst✝ : Functor.IsLocalization L W\nX Y : C\nz₁ z₂ : LeftFraction₂ W X Y\nh : LeftFraction₂Rel z₁ z₂\n⊢ LeftFractionRel (LeftFraction₂.fst z₁) (LeftFraction₂.fst z₂)"}
{"statement_idx": 43, "goal_state": "C : Type u_1\nD : Type u_2\ninst✝² : Category.{u_3, u_1} C\ninst✝¹ : Category.{?u.8236, u_2} D\nL : C ⥤ D\nW : MorphismProperty C\ninst✝ : Functor.IsLocalization L W\nX Y : C\nz₁ z₂ : LeftFraction₂ W X Y\nh : LeftFraction₂Rel z₁ z₂\n⊢ LeftFractionRel (LeftFraction₂.snd z₁) (LeftFraction₂.snd z₂)"}
{"statement_idx": 44, "goal_state": "C : Type u_1\nD : Type u_2\ninst✝³ : Category.{u_3, u_1} C\ninst✝² : Category.{u_4, u_2} D\nL : C ⥤ D\nW : MorphismProperty C\ninst✝¹ : Functor.IsLocalization L W\ninst✝ : HasLeftCalculusOfFractions W\nX Y : C\nφ ψ : LeftFraction₂ W X Y\n⊢ LeftFraction.map (fst φ) L ⋯ = LeftFraction.map (fst ψ) L ⋯ ∧\n      LeftFraction.map (snd φ) L ⋯ = LeftFraction.map (snd ψ) L ⋯ ↔\n    LeftFraction₂Rel φ ψ"}
{"statement_idx": 45, "goal_state": "C : Type u_1\nD : Type u_2\ninst✝³ : Category.{u_3, u_1} C\ninst✝² : Category.{?u.16121, u_2} D\nL : C ⥤ D\nW : MorphismProperty C\ninst✝¹ : Functor.IsLocalization L W\nX Y : C\nφ : RightFraction₂ W X Y\ninst✝ : HasLeftCalculusOfFractions W\n⊢ ∃ ψ, φ.f ≫ ψ.s = φ.s ≫ ψ.f ∧ φ.f' ≫ ψ.s = φ.s ≫ ψ.f'"}
{"statement_idx": 46, "goal_state": "C : Type u_1\nD : Type u_2\ninst✝³ : Category.{u_4, u_1} C\ninst✝² : Category.{u_3, u_2} D\nL : C ⥤ D\nW : MorphismProperty C\ninst✝¹ : Functor.IsLocalization L W\ninst✝ : HasLeftCalculusOfFractions W\nX Y : C\nf f' : L.obj X ⟶ L.obj Y\n⊢ ∃ φ, f = LeftFraction.map (LeftFraction₂.fst φ) L ⋯ ∧ f' = LeftFraction.map (LeftFraction₂.snd φ) L ⋯"}
{"statement_idx": 47, "goal_state": "C : Type u_1\nD : Type u_2\ninst✝³ : Category.{u_4, u_1} C\ninst✝² : Category.{u_3, u_2} D\nL : C ⥤ D\nW : MorphismProperty C\ninst✝¹ : Functor.IsLocalization L W\ninst✝ : HasLeftCalculusOfFractions W\nX Y : C\nf f' f'' : L.obj X ⟶ L.obj Y\n⊢ ∃ φ,\n    f = LeftFraction.map (LeftFraction₃.fst φ) L ⋯ ∧\n      f' = LeftFraction.map (LeftFraction₃.snd φ) L ⋯ ∧ f'' = LeftFraction.map (LeftFraction₃.thd φ) L ⋯"}
{"statement_idx": 48, "goal_state": "m : Type u_1\nn : Type u_2\no : Type u_3\nR : Type u_4\nS : Type u_5\ninst✝³ : Fintype n\ninst✝² : Fintype o\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nM : Matrix m n R\ni : m\nc : n → R\n⊢ (eval c) (toMvPolynomial M i) = (M *ᵥ c) i"}
{"statement_idx": 49, "goal_state": "m : Type u_1\nn : Type u_2\no : Type u_3\nR : Type u_4\nS : Type u_5\ninst✝³ : Fintype n\ninst✝² : Fintype o\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : R →+* S\nM : Matrix m n R\ni : m\n⊢ toMvPolynomial (map M ⇑f) i = (MvPolynomial.map f) (toMvPolynomial M i)"}
